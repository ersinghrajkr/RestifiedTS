import { expect } from 'chai';
import { SnapshotStore } from '../../src/core/stores/SnapshotStore';
import { promises as fs } from 'fs';
import { join } from 'path';

describe('Snapshot Testing Functionality Tests', () => {
  let snapshotStore: SnapshotStore;
  const testSnapshotDir = join(__dirname, '../../test-snapshots');

  beforeEach(() => {
    snapshotStore = new SnapshotStore(testSnapshotDir);
  });

  afterEach(async () => {
    // Clean up test snapshots
    try {
      await fs.rmdir(testSnapshotDir, { recursive: true });
    } catch (error) {
      // Ignore cleanup errors
    }
  });

  describe('SnapshotStore Basic Operations', () => {
    it('should initialize snapshot store without errors', () => {
      expect(snapshotStore).to.be.instanceOf(SnapshotStore);
    });

    it('should save snapshots to disk', async () => {
      const testData = {
        id: 1,
        name: 'Test User',
        email: 'test@example.com',
        timestamp: '2024-01-01T00:00:00Z'
      };

      await snapshotStore.save('user-profile', testData);
      
      // Verify file was created
      const snapshotPath = join(testSnapshotDir, 'user-profile.json');
      const exists = await fs.access(snapshotPath).then(() => true).catch(() => false);
      expect(exists).to.be.true;
    });

    it('should load snapshots from disk', async () => {
      const testData = {
        posts: [
          { id: 1, title: 'First Post' },
          { id: 2, title: 'Second Post' }
        ],
        meta: { total: 2, page: 1 }
      };

      await snapshotStore.save('posts-list', testData);
      const loaded = await snapshotStore.load('posts-list');
      
      expect(loaded).to.deep.equal(testData);
    });

    it('should return null for non-existent snapshots', async () => {
      const loaded = await snapshotStore.load('non-existent-snapshot');
      expect(loaded).to.be.null;
    });

    it('should check if snapshots exist', async () => {
      const testData = { test: 'data' };
      
      expect(await snapshotStore.exists('test-snapshot')).to.be.false;
      
      await snapshotStore.save('test-snapshot', testData);
      
      expect(await snapshotStore.exists('test-snapshot')).to.be.true;
    });

    it('should delete snapshots', async () => {
      const testData = { temporary: 'data' };
      
      await snapshotStore.save('temp-snapshot', testData);
      expect(await snapshotStore.exists('temp-snapshot')).to.be.true;
      
      await snapshotStore.delete('temp-snapshot');
      expect(await snapshotStore.exists('temp-snapshot')).to.be.false;
    });

    it('should list all snapshots', async () => {
      await snapshotStore.save('snapshot1', { data: 1 });
      await snapshotStore.save('snapshot2', { data: 2 });
      await snapshotStore.save('snapshot3', { data: 3 });
      
      const snapshots = await snapshotStore.list();
      
      expect(snapshots).to.include('snapshot1');
      expect(snapshots).to.include('snapshot2');
      expect(snapshots).to.include('snapshot3');
      expect(snapshots).to.have.length(3);
    });
  });

  describe('Snapshot Comparison', () => {
    it('should compare snapshots for equality', async () => {
      const originalData = {
        user: {
          id: 123,
          name: 'John Doe',
          settings: {
            theme: 'dark',
            notifications: true
          }
        }
      };

      const identicalData = {
        user: {
          id: 123,
          name: 'John Doe',
          settings: {
            theme: 'dark',
            notifications: true
          }
        }
      };

      await snapshotStore.save('original-user', originalData);
      
      const comparison = await snapshotStore.compare('original-user', identicalData);
      expect(comparison.isMatch).to.be.true;
      expect(comparison.differences).to.be.empty;
    });

    it('should detect differences in snapshots', async () => {
      const originalData = {
        id: 1,
        name: 'Original Name',
        status: 'active',
        tags: ['tag1', 'tag2']
      };

      const modifiedData = {
        id: 1,
        name: 'Modified Name',
        status: 'inactive',
        tags: ['tag1', 'tag3']
      };

      await snapshotStore.save('comparison-test', originalData);
      
      const comparison = await snapshotStore.compare('comparison-test', modifiedData);
      expect(comparison.isMatch).to.be.false;
      expect(comparison.differences).to.not.be.empty;
      
      // Should detect specific field changes
      expect(comparison.differences).to.include.something.that.matches(/name/);
      expect(comparison.differences).to.include.something.that.matches(/status/);
    });

    it('should handle array differences', async () => {
      const originalArray = [
        { id: 1, name: 'Item 1' },
        { id: 2, name: 'Item 2' },
        { id: 3, name: 'Item 3' }
      ];

      const modifiedArray = [
        { id: 1, name: 'Item 1' },
        { id: 2, name: 'Modified Item 2' },
        { id: 4, name: 'Item 4' }
      ];

      await snapshotStore.save('array-comparison', originalArray);
      
      const comparison = await snapshotStore.compare('array-comparison', modifiedArray);
      expect(comparison.isMatch).to.be.false;
      expect(comparison.differences).to.not.be.empty;
    });

    it('should support custom comparison options', async () => {
      const originalData = {
        id: 1,
        timestamp: '2024-01-01T10:00:00Z',
        data: 'important data'
      };

      const modifiedData = {
        id: 1,
        timestamp: '2024-01-01T11:00:00Z', // Different timestamp
        data: 'important data'
      };

      await snapshotStore.save('custom-comparison', originalData);
      
      // Ignore timestamp field in comparison
      const comparison = await snapshotStore.compare('custom-comparison', modifiedData, {
        ignoreFields: ['timestamp']
      });
      
      expect(comparison.isMatch).to.be.true;
    });
  });

  describe('Snapshot Versioning', () => {
    it('should support versioned snapshots', async () => {
      const v1Data = { version: 1, data: 'version 1 data' };
      const v2Data = { version: 2, data: 'version 2 data' };
      
      await snapshotStore.save('versioned-snapshot', v1Data, { version: '1.0' });
      await snapshotStore.save('versioned-snapshot', v2Data, { version: '2.0' });
      
      const loadedV1 = await snapshotStore.load('versioned-snapshot', { version: '1.0' });
      const loadedV2 = await snapshotStore.load('versioned-snapshot', { version: '2.0' });
      
      expect(loadedV1).to.deep.equal(v1Data);
      expect(loadedV2).to.deep.equal(v2Data);
    });

    it('should list versions of a snapshot', async () => {
      await snapshotStore.save('multi-version', { v: 1 }, { version: '1.0' });
      await snapshotStore.save('multi-version', { v: 2 }, { version: '1.1' });
      await snapshotStore.save('multi-version', { v: 3 }, { version: '2.0' });
      
      const versions = await snapshotStore.getVersions('multi-version');
      
      expect(versions).to.include('1.0');
      expect(versions).to.include('1.1');
      expect(versions).to.include('2.0');
      expect(versions).to.have.length(3);
    });

    it('should get the latest version by default', async () => {
      await snapshotStore.save('latest-test', { data: 'old' }, { version: '1.0' });
      await snapshotStore.save('latest-test', { data: 'new' }, { version: '2.0' });
      
      const latest = await snapshotStore.load('latest-test'); // No version specified
      
      expect(latest.data).to.equal('new');
    });
  });

  describe('Snapshot Metadata', () => {
    it('should store metadata with snapshots', async () => {
      const testData = { content: 'test data' };
      const metadata = {
        createdBy: 'test-suite',
        description: 'Test snapshot for metadata',
        tags: ['test', 'metadata']
      };

      await snapshotStore.save('metadata-test', testData, { metadata });
      
      const snapshotInfo = await snapshotStore.getInfo('metadata-test');
      
      expect(snapshotInfo.metadata).to.deep.equal(metadata);
      expect(snapshotInfo).to.have.property('createdAt');
      expect(snapshotInfo).to.have.property('size');
    });

    it('should update snapshot metadata', async () => {
      const testData = { content: 'test' };
      
      await snapshotStore.save('metadata-update', testData, {
        metadata: { tag: 'original' }
      });
      
      await snapshotStore.updateMetadata('metadata-update', {
        tag: 'updated',
        newField: 'added'
      });
      
      const info = await snapshotStore.getInfo('metadata-update');
      expect(info.metadata.tag).to.equal('updated');
      expect(info.metadata.newField).to.equal('added');
    });

    it('should search snapshots by metadata', async () => {
      await snapshotStore.save('api-test-1', { data: 1 }, {
        metadata: { type: 'api', environment: 'test' }
      });
      
      await snapshotStore.save('api-prod-1', { data: 2 }, {
        metadata: { type: 'api', environment: 'production' }
      });
      
      await snapshotStore.save('ui-test-1', { data: 3 }, {
        metadata: { type: 'ui', environment: 'test' }
      });
      
      const apiSnapshots = await snapshotStore.search({ type: 'api' });
      const testSnapshots = await snapshotStore.search({ environment: 'test' });
      
      expect(apiSnapshots).to.have.length(2);
      expect(testSnapshots).to.have.length(2);
      expect(apiSnapshots).to.include('api-test-1');
      expect(apiSnapshots).to.include('api-prod-1');
    });
  });

  describe('Snapshot Storage Options', () => {
    it('should support different storage formats', async () => {
      const testData = {
        complexObject: {
          array: [1, 2, 3],
          nested: { deep: { value: 'test' } }
        }
      };

      // Save in different formats
      await snapshotStore.save('format-json', testData, { format: 'json' });
      await snapshotStore.save('format-yaml', testData, { format: 'yaml' });
      
      const jsonLoaded = await snapshotStore.load('format-json');
      const yamlLoaded = await snapshotStore.load('format-yaml');
      
      expect(jsonLoaded).to.deep.equal(testData);
      expect(yamlLoaded).to.deep.equal(testData);
    });

    it('should compress large snapshots', async () => {
      const largeData = {
        items: Array.from({ length: 1000 }, (_, i) => ({
          id: i,
          data: `Large dataset item ${i}`.repeat(10)
        }))
      };

      await snapshotStore.save('large-snapshot', largeData, { compress: true });
      const loaded = await snapshotStore.load('large-snapshot');
      
      expect(loaded).to.deep.equal(largeData);
      
      // Verify compression was applied
      const info = await snapshotStore.getInfo('large-snapshot');
      expect(info.compressed).to.be.true;
    });

    it('should handle snapshot expiration', async () => {
      const testData = { temporary: 'data' };
      
      await snapshotStore.save('expiring-snapshot', testData, {
        expiresIn: 100 // 100ms
      });
      
      expect(await snapshotStore.exists('expiring-snapshot')).to.be.true;
      
      // Wait for expiration
      await new Promise(resolve => setTimeout(resolve, 150));
      
      expect(await snapshotStore.exists('expiring-snapshot')).to.be.false;
    });
  });
});