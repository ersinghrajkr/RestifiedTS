import { expect } from 'chai';
import { SnapshotStore } from '../../../src/core/stores/SnapshotStore';

describe('SnapshotStore System Tests', () => {
  let snapshotStore: SnapshotStore;

  beforeEach(() => {
    snapshotStore = new SnapshotStore();
  });

  describe('Basic Snapshot Operations', () => {
    it('should create SnapshotStore instance', () => {
      expect(snapshotStore).to.be.instanceOf(SnapshotStore);
    });

    it('should initialize with default configuration', () => {
      const defaultStore = new SnapshotStore();
      expect(defaultStore).to.be.instanceOf(SnapshotStore);
    });

    it('should initialize with custom configuration', () => {
      const config = {
        snapshotDir: './custom-snapshots',
        updateMode: false,
        ignoreFields: ['timestamp', 'id'],
        autoLoad: true
      };
      
      const customStore = new SnapshotStore(config);
      expect(customStore).to.be.instanceOf(SnapshotStore);
    });
  });

  describe('Snapshot Creation and Storage', () => {
    it('should create snapshots from response data', () => {
      const responseData = {
        users: [
          { id: 1, name: 'John', email: 'john@example.com' },
          { id: 2, name: 'Jane', email: 'jane@example.com' }
        ],
        pagination: { page: 1, total: 2 }
      };

      expect(() => {
        snapshotStore.save('users-list-snapshot', responseData);
      }).to.not.throw();
    });

    it('should create snapshots with metadata', () => {
      const testData = { message: 'test snapshot' };
      const metadata = {
        testName: 'user-api-test',
        timestamp: new Date(),
        environment: 'testing'
      };

      expect(() => {
        snapshotStore.save('test-snapshot', testData, metadata);
      }).to.not.throw();
    });

    it('should handle complex nested data structures', () => {
      const complexData = {
        level1: {
          level2: {
            level3: {
              array: [1, 2, { nested: true }],
              map: new Map([['key1', 'value1'], ['key2', 'value2']]),
              date: new Date(),
              regex: /test-pattern/gi
            }
          }
        }
      };

      expect(() => {
        snapshotStore.save('complex-snapshot', complexData);
      }).to.not.throw();
    });
  });

  describe('Snapshot Retrieval and Loading', () => {
    beforeEach(() => {
      // Create test snapshots
      snapshotStore.save('baseline-snapshot', {
        version: '1.0',
        features: ['feature1', 'feature2'],
        config: { debug: false }
      });

      snapshotStore.save('updated-snapshot', {
        version: '1.1',
        features: ['feature1', 'feature2', 'feature3'],
        config: { debug: true }
      });
    });

    it('should load existing snapshots', () => {
      const loaded = snapshotStore.load('baseline-snapshot');
      expect(loaded).to.exist;
      expect(loaded.version).to.equal('1.0');
      expect(loaded.features).to.include('feature1', 'feature2');
    });

    it('should handle loading non-existent snapshots', () => {
      const nonExistent = snapshotStore.load('non-existent-snapshot');
      expect(nonExistent).to.be.null;
    });

    it('should check snapshot existence', () => {
      expect(snapshotStore.exists('baseline-snapshot')).to.be.true;
      expect(snapshotStore.exists('non-existent')).to.be.false;
    });

    it('should list all snapshot names', () => {
      const snapshots = snapshotStore.list();
      expect(snapshots).to.include('baseline-snapshot', 'updated-snapshot');
      expect(snapshots).to.have.length.at.least(2);
    });
  });

  describe('Snapshot Comparison and Diffing', () => {
    beforeEach(() => {
      snapshotStore.save('original-data', {
        users: [
          { id: 1, name: 'John', status: 'active' },
          { id: 2, name: 'Jane', status: 'active' }
        ],
        totalCount: 2,
        lastUpdated: '2025-01-01'
      });

      snapshotStore.save('modified-data', {
        users: [
          { id: 1, name: 'John', status: 'inactive' }, // status changed
          { id: 2, name: 'Jane', status: 'active' },
          { id: 3, name: 'Bob', status: 'active' }     // new user added
        ],
        totalCount: 3,                                 // count updated
        lastUpdated: '2025-01-02'                     // date updated
      });
    });

    it('should compare snapshots and detect differences', () => {
      const comparison = snapshotStore.compare('original-data', 'modified-data');
      
      expect(comparison).to.exist;
      expect(comparison.isMatch).to.be.false;
      expect(comparison.differences).to.exist;
      expect(comparison.differences.length).to.be.greaterThan(0);
    });

    it('should identify specific types of changes', () => {
      const comparison = snapshotStore.compare('original-data', 'modified-data');
      
      // Should detect added, modified, and removed items
      const changeTypes = comparison.differences.map(diff => diff.type);
      expect(changeTypes).to.include('added');
      expect(changeTypes).to.include('modified');
    });

    it('should compare identical snapshots', () => {
      const identicalData = {
        message: 'same data',
        count: 42
      };

      snapshotStore.save('identical-1', identicalData);
      snapshotStore.save('identical-2', identicalData);

      const comparison = snapshotStore.compare('identical-1', 'identical-2');
      expect(comparison.isMatch).to.be.true;
      expect(comparison.differences).to.have.length(0);
    });
  });

  describe('Snapshot Validation and Schema Checking', () => {
    it('should validate snapshots against schemas', () => {
      const userData = {
        id: 1,
        name: 'John Doe',
        email: 'john@example.com',
        age: 30
      };

      const userSchema = {
        type: 'object',
        properties: {
          id: { type: 'number' },
          name: { type: 'string' },
          email: { type: 'string' },
          age: { type: 'number' }
        },
        required: ['id', 'name', 'email']
      };

      snapshotStore.save('user-data', userData);
      const isValid = snapshotStore.validate('user-data', userSchema);
      
      expect(isValid).to.be.true;
    });

    it('should detect schema violations', () => {
      const invalidUserData = {
        id: 'not-a-number',  // Should be number
        name: 123,           // Should be string
        // email missing       // Required field
        age: 'thirty'        // Should be number
      };

      const userSchema = {
        type: 'object',
        properties: {
          id: { type: 'number' },
          name: { type: 'string' },
          email: { type: 'string' },
          age: { type: 'number' }
        },
        required: ['id', 'name', 'email']
      };

      snapshotStore.save('invalid-user-data', invalidUserData);
      const isValid = snapshotStore.validate('invalid-user-data', userSchema);
      
      expect(isValid).to.be.false;
    });
  });

  describe('Snapshot Versioning and History', () => {
    it('should maintain snapshot versions', () => {
      const baselineData = { version: 1, features: ['a'] };
      const v2Data = { version: 2, features: ['a', 'b'] };
      const v3Data = { version: 3, features: ['a', 'b', 'c'] };

      snapshotStore.save('api-v1', baselineData);
      snapshotStore.save('api-v2', v2Data);
      snapshotStore.save('api-v3', v3Data);

      const versions = snapshotStore.getVersions('api');
      expect(versions).to.include('api-v1', 'api-v2', 'api-v3');
    });

    it('should support snapshot metadata queries', () => {
      const testData = { test: 'data' };
      const metadata = {
        testName: 'integration-test',
        environment: 'staging',
        timestamp: new Date()
      };

      snapshotStore.save('metadata-test', testData, metadata);
      const info = snapshotStore.getInfo('metadata-test');

      expect(info).to.exist;
      expect(info.metadata).to.deep.include(metadata);
    });
  });

  describe('Snapshot Organization and Management', () => {
    beforeEach(() => {
      // Create organized snapshots
      snapshotStore.save('users/list', { users: [] });
      snapshotStore.save('users/details', { user: {} });
      snapshotStore.save('products/catalog', { products: [] });
      snapshotStore.save('orders/history', { orders: [] });
    });

    it('should support hierarchical snapshot organization', () => {
      const userSnapshots = snapshotStore.search('users/');
      const productSnapshots = snapshotStore.search('products/');

      expect(userSnapshots).to.include('users/list', 'users/details');
      expect(productSnapshots).to.include('products/catalog');
    });

    it('should allow snapshot cleanup and deletion', () => {
      snapshotStore.save('temporary-snapshot', { temp: true });
      expect(snapshotStore.exists('temporary-snapshot')).to.be.true;

      snapshotStore.delete('temporary-snapshot');
      expect(snapshotStore.exists('temporary-snapshot')).to.be.false;
    });

    it('should support bulk operations', () => {
      const bulkData = {
        'bulk-1': { id: 1 },
        'bulk-2': { id: 2 },
        'bulk-3': { id: 3 }
      };

      snapshotStore.saveBulk(bulkData);

      expect(snapshotStore.exists('bulk-1')).to.be.true;
      expect(snapshotStore.exists('bulk-2')).to.be.true;
      expect(snapshotStore.exists('bulk-3')).to.be.true;
    });
  });

  describe('Performance and Optimization', () => {
    it('should handle large snapshots efficiently', () => {
      const largeData = {
        items: Array.from({ length: 1000 }, (_, i) => ({
          id: i,
          name: `Item ${i}`,
          description: `Description for item ${i}`.repeat(10),
          metadata: {
            tags: [`tag-${i}`, `category-${i % 10}`],
            metrics: {
              views: Math.random() * 1000,
              likes: Math.random() * 100
            }
          }
        }))
      };

      const startTime = Date.now();
      snapshotStore.save('large-snapshot', largeData);
      const saveTime = Date.now() - startTime;

      const loadStartTime = Date.now();
      const loaded = snapshotStore.load('large-snapshot');
      const loadTime = Date.now() - loadStartTime;

      expect(loaded.items).to.have.length(1000);
      expect(saveTime).to.be.lessThan(1000); // Should save within 1 second
      expect(loadTime).to.be.lessThan(500);  // Should load within 0.5 seconds
    });

    it('should handle concurrent snapshot operations', async () => {
      const promises = [];

      for (let i = 0; i < 20; i++) {
        promises.push(Promise.resolve().then(() => {
          snapshotStore.save(`concurrent-${i}`, { id: i, data: `data-${i}` });
          return snapshotStore.load(`concurrent-${i}`);
        }));
      }

      const results = await Promise.all(promises);
      expect(results).to.have.length(20);
      expect(results.every(result => result !== null)).to.be.true;
    });
  });

  describe('Error Handling and Edge Cases', () => {
    it('should handle null and undefined data gracefully', () => {
      expect(() => snapshotStore.save('null-snapshot', null)).to.not.throw();
      expect(() => snapshotStore.save('undefined-snapshot', undefined)).to.not.throw();
    });

    it('should handle circular references', () => {
      const circularData: any = { name: 'circular' };
      circularData.self = circularData;

      expect(() => {
        snapshotStore.save('circular-snapshot', circularData);
      }).to.not.throw();
    });

    it('should handle invalid snapshot names', () => {
      expect(() => snapshotStore.save('', { test: 'data' })).to.not.throw();
      expect(() => snapshotStore.save(null as any, { test: 'data' })).to.not.throw();
    });

    it('should handle corrupted snapshot data', () => {
      // Simulate corruption by directly manipulating storage
      const normalData = { test: 'normal' };
      snapshotStore.save('normal-snapshot', normalData);

      // Attempt to load should handle errors gracefully
      expect(() => snapshotStore.load('normal-snapshot')).to.not.throw();
    });
  });

  describe('Integration with Test Framework', () => {
    it('should integrate with assertion workflows', () => {
      const expectedResponse = {
        status: 'success',
        data: { users: [{ id: 1, name: 'Test User' }] }
      };

      const actualResponse = {
        status: 'success',
        data: { users: [{ id: 1, name: 'Test User' }] }
      };

      snapshotStore.save('expected-response', expectedResponse);
      const comparison = snapshotStore.compareWith('expected-response', actualResponse);

      expect(comparison.isMatch).to.be.true;
    });

    it('should support regression testing workflows', () => {
      // Baseline snapshot
      snapshotStore.save('api-baseline', {
        endpoints: ['/users', '/products'],
        features: ['auth', 'crud'],
        performance: { avgResponseTime: 200 }
      });

      // Current test result
      const currentResult = {
        endpoints: ['/users', '/products', '/orders'], // new endpoint added
        features: ['auth', 'crud', 'analytics'],       // new feature added
        performance: { avgResponseTime: 180 }          // performance improved
      };

      const comparison = snapshotStore.compareWith('api-baseline', currentResult);
      
      expect(comparison.differences).to.exist;
      // Should detect the additions as changes
      expect(comparison.differences.some(diff => diff.type === 'added')).to.be.true;
    });

    it('should support test data fixtures', () => {
      const testFixtures = {
        users: [
          { id: 1, name: 'Admin User', role: 'admin' },
          { id: 2, name: 'Regular User', role: 'user' }
        ],
        products: [
          { id: 'p1', name: 'Product 1', price: 99.99 },
          { id: 'p2', name: 'Product 2', price: 149.99 }
        ]
      };

      snapshotStore.save('test-fixtures', testFixtures);
      const loaded = snapshotStore.load('test-fixtures');

      expect(loaded.users).to.have.length(2);
      expect(loaded.products).to.have.length(2);
      expect(loaded.users[0].role).to.equal('admin');
    });
  });
});