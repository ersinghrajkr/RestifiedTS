/**
 * PostgreSQL Database Adapter for RestifiedTS
 * 
 * Provides PostgreSQL-specific database connectivity and operations using pg driver.
 */

import { 
  DatabaseAdapter, 
  DatabaseConfig, 
  DatabaseConnection, 
  ConnectionPool, 
  QueryBuilder,
  MigrationManager,
  DatabaseTestUtilities,
  QueryField
} from '../DatabaseTypes';

import { PostgreSQLConnection } from './connections/PostgreSQLConnection';
import { PostgreSQLConnectionPool } from './connections/PostgreSQLConnectionPool';
import { PostgreSQLQueryBuilder } from './builders/PostgreSQLQueryBuilder';
import { PostgreSQLMigrationManager } from './migrations/PostgreSQLMigrationManager';
import { PostgreSQLTestUtilities } from './testing/PostgreSQLTestUtilities';

export class PostgreSQLAdapter implements DatabaseAdapter {
  
  /**
   * Create a new PostgreSQL connection
   */
  async connect(config: DatabaseConfig): Promise<DatabaseConnection> {
    if (config.type !== 'postgresql') {
      throw new Error('Invalid database type for PostgreSQL adapter');
    }

    const connection = new PostgreSQLConnection(config);
    await connection.connect();
    return connection;
  }

  /**
   * Create a PostgreSQL connection pool
   */
  async createConnectionPool(config: DatabaseConfig): Promise<ConnectionPool> {
    if (config.type !== 'postgresql') {
      throw new Error('Invalid database type for PostgreSQL adapter');
    }

    const pool = new PostgreSQLConnectionPool(config);
    await pool.initialize();
    return pool;
  }

  /**
   * Create a PostgreSQL query builder
   */
  createQueryBuilder(): QueryBuilder {
    return new PostgreSQLQueryBuilder();
  }

  /**
   * Create a PostgreSQL migration manager
   */
  createMigrationManager(): MigrationManager {
    return new PostgreSQLMigrationManager();
  }

  /**
   * Create PostgreSQL test utilities
   */
  createTestUtilities(): DatabaseTestUtilities {
    return new PostgreSQLTestUtilities();
  }

  /**
   * Escape PostgreSQL identifier (table name, column name, etc.)
   */
  escapeIdentifier(identifier: string): string {
    return `"${identifier.replace(/"/g, '""')}"`;
  }

  /**
   * Escape PostgreSQL value
   */
  escapeValue(value: any): string {
    if (value === null || value === undefined) {
      return 'NULL';
    }
    
    if (typeof value === 'string') {
      return `'${value.replace(/'/g, "''")}'`;
    }
    
    if (typeof value === 'number') {
      return value.toString();
    }
    
    if (typeof value === 'boolean') {
      return value ? 'TRUE' : 'FALSE';
    }
    
    if (value instanceof Date) {
      return `'${value.toISOString()}'`;
    }
    
    if (Array.isArray(value)) {
      return `ARRAY[${value.map(v => this.escapeValue(v)).join(', ')}]`;
    }
    
    if (typeof value === 'object') {
      return `'${JSON.stringify(value).replace(/'/g, "''")}'::jsonb`;
    }
    
    return `'${String(value).replace(/'/g, "''")}'`;
  }

  /**
   * Build PostgreSQL LIMIT clause
   */
  buildLimitClause(limit?: number, offset?: number): string {
    let clause = '';
    
    if (limit) {
      clause += `LIMIT ${limit}`;
    }
    
    if (offset) {
      clause += ` OFFSET ${offset}`;
    }
    
    return clause.trim();
  }

  /**
   * Get current timestamp in PostgreSQL format
   */
  getCurrentTimestamp(): string {
    return 'CURRENT_TIMESTAMP';
  }

  /**
   * Check if table exists
   */
  async tableExists(connection: DatabaseConnection, tableName: string): Promise<boolean> {
    const result = await connection.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = $1
      ) as exists
    `, [tableName]);
    
    return result[0]?.exists || false;
  }

  /**
   * Get table columns information
   */
  async getTableColumns(connection: DatabaseConnection, tableName: string): Promise<QueryField[]> {
    const result = await connection.query(`
      SELECT 
        column_name as name,
        data_type as type,
        is_nullable as nullable,
        column_default as default_value,
        CASE 
          WHEN column_default LIKE 'nextval%' THEN true
          ELSE false
        END as auto_increment
      FROM information_schema.columns 
      WHERE table_schema = 'public' 
      AND table_name = $1
      ORDER BY ordinal_position
    `, [tableName]);

    // Get primary key information
    const pkResult = await connection.query(`
      SELECT column_name
      FROM information_schema.key_column_usage kcu
      JOIN information_schema.table_constraints tc 
        ON kcu.constraint_name = tc.constraint_name
      WHERE tc.table_schema = 'public'
      AND tc.table_name = $1
      AND tc.constraint_type = 'PRIMARY KEY'
    `, [tableName]);

    const primaryKeys = new Set(pkResult.map((row: any) => row.column_name));

    return result.map((row: any) => ({
      name: row.name,
      type: row.type,
      nullable: row.nullable === 'YES',
      primaryKey: primaryKeys.has(row.name),
      autoIncrement: row.auto_increment
    }));
  }

  /**
   * Get table indexes
   */
  async getTableIndexes(connection: DatabaseConnection, tableName: string): Promise<string[]> {
    const result = await connection.query(`
      SELECT indexname as index_name
      FROM pg_indexes 
      WHERE schemaname = 'public' 
      AND tablename = $1
      AND indexname NOT LIKE '%_pkey'
    `, [tableName]);

    return result.map((row: any) => row.index_name);
  }

  /**
   * Create database if not exists
   */
  async createDatabase(connection: DatabaseConnection, databaseName: string): Promise<void> {
    // PostgreSQL doesn't support IF NOT EXISTS for CREATE DATABASE in older versions
    try {
      await connection.query(`CREATE DATABASE ${this.escapeIdentifier(databaseName)}`);
    } catch (error: any) {
      // Ignore error if database already exists
      if (!error.message?.includes('already exists')) {
        throw error;
      }
    }
  }

  /**
   * Drop database if exists
   */
  async dropDatabase(connection: DatabaseConnection, databaseName: string): Promise<void> {
    await connection.query(`DROP DATABASE IF EXISTS ${this.escapeIdentifier(databaseName)}`);
  }

  /**
   * Get PostgreSQL server version
   */
  async getServerVersion(connection: DatabaseConnection): Promise<string> {
    const result = await connection.query('SELECT version() as version');
    return result[0]?.version || 'Unknown';
  }

  /**
   * Get database size in bytes
   */
  async getDatabaseSize(connection: DatabaseConnection, databaseName?: string): Promise<number> {
    const dbName = databaseName || 'current_database()';
    const result = await connection.query(`
      SELECT pg_database_size(${typeof dbName === 'string' && !dbName.includes('(') ? `'${dbName}'` : dbName}) as size_bytes
    `);
    
    return parseInt(result[0]?.size_bytes || '0');
  }

  /**
   * Get table row count
   */
  async getTableRowCount(connection: DatabaseConnection, tableName: string): Promise<number> {
    const result = await connection.query(`SELECT COUNT(*) as count FROM ${this.escapeIdentifier(tableName)}`);
    return parseInt(result[0]?.count || '0');
  }

  /**
   * Vacuum table
   */
  async vacuumTable(connection: DatabaseConnection, tableName: string, full: boolean = false): Promise<void> {
    const vacuumType = full ? 'VACUUM FULL' : 'VACUUM';
    await connection.query(`${vacuumType} ${this.escapeIdentifier(tableName)}`);
  }

  /**
   * Analyze table
   */
  async analyzeTable(connection: DatabaseConnection, tableName: string): Promise<void> {
    await connection.query(`ANALYZE ${this.escapeIdentifier(tableName)}`);
  }

  /**
   * Get table statistics
   */
  async getTableStatistics(connection: DatabaseConnection, tableName: string): Promise<any> {
    const result = await connection.query(`
      SELECT 
        schemaname,
        tablename,
        attname,
        n_distinct,
        correlation,
        most_common_vals,
        most_common_freqs,
        histogram_bounds
      FROM pg_stats 
      WHERE schemaname = 'public' 
      AND tablename = $1
    `, [tableName]);

    return result;
  }

  /**
   * Get active connections
   */
  async getActiveConnections(connection: DatabaseConnection): Promise<any[]> {
    return await connection.query(`
      SELECT 
        pid,
        usename,
        application_name,
        client_addr,
        client_port,
        backend_start,
        state,
        query
      FROM pg_stat_activity 
      WHERE state = 'active'
      AND pid <> pg_backend_pid()
    `);
  }

  /**
   * Terminate connection by PID
   */
  async terminateConnection(connection: DatabaseConnection, pid: number): Promise<void> {
    await connection.query('SELECT pg_terminate_backend($1)', [pid]);
  }

  /**
   * Create user/role
   */
  async createUser(connection: DatabaseConnection, username: string, password: string, options: any = {}): Promise<void> {
    let createQuery = `CREATE USER ${this.escapeIdentifier(username)} WITH PASSWORD '${password}'`;
    
    if (options.superuser) createQuery += ' SUPERUSER';
    if (options.createdb) createQuery += ' CREATEDB';
    if (options.createrole) createQuery += ' CREATEROLE';
    if (options.login !== false) createQuery += ' LOGIN';
    
    await connection.query(createQuery);
  }

  /**
   * Drop user/role
   */
  async dropUser(connection: DatabaseConnection, username: string): Promise<void> {
    await connection.query(`DROP USER IF EXISTS ${this.escapeIdentifier(username)}`);
  }

  /**
   * Grant privileges
   */
  async grantPrivileges(
    connection: DatabaseConnection, 
    privileges: string, 
    objectType: string,
    objectName: string, 
    username: string
  ): Promise<void> {
    await connection.query(`
      GRANT ${privileges} ON ${objectType} ${this.escapeIdentifier(objectName)} 
      TO ${this.escapeIdentifier(username)}
    `);
  }

  /**
   * Create schema
   */
  async createSchema(connection: DatabaseConnection, schemaName: string, owner?: string): Promise<void> {
    let createQuery = `CREATE SCHEMA IF NOT EXISTS ${this.escapeIdentifier(schemaName)}`;
    
    if (owner) {
      createQuery += ` AUTHORIZATION ${this.escapeIdentifier(owner)}`;
    }
    
    await connection.query(createQuery);
  }

  /**
   * Drop schema
   */
  async dropSchema(connection: DatabaseConnection, schemaName: string, cascade: boolean = false): Promise<void> {
    const cascadeClause = cascade ? ' CASCADE' : '';
    await connection.query(`DROP SCHEMA IF EXISTS ${this.escapeIdentifier(schemaName)}${cascadeClause}`);
  }

  /**
   * Get database schemas
   */
  async getSchemas(connection: DatabaseConnection): Promise<string[]> {
    const result = await connection.query(`
      SELECT schema_name 
      FROM information_schema.schemata 
      WHERE schema_name NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
      ORDER BY schema_name
    `);

    return result.map((row: any) => row.schema_name);
  }

  /**
   * Enable/disable extension
   */
  async createExtension(connection: DatabaseConnection, extensionName: string, schema?: string): Promise<void> {
    let createQuery = `CREATE EXTENSION IF NOT EXISTS ${this.escapeIdentifier(extensionName)}`;
    
    if (schema) {
      createQuery += ` SCHEMA ${this.escapeIdentifier(schema)}`;
    }
    
    await connection.query(createQuery);
  }

  /**
   * Drop extension
   */
  async dropExtension(connection: DatabaseConnection, extensionName: string, cascade: boolean = false): Promise<void> {
    const cascadeClause = cascade ? ' CASCADE' : '';
    await connection.query(`DROP EXTENSION IF EXISTS ${this.escapeIdentifier(extensionName)}${cascadeClause}`);
  }

  /**
   * Get installed extensions
   */
  async getExtensions(connection: DatabaseConnection): Promise<any[]> {
    return await connection.query(`
      SELECT 
        extname as name,
        extversion as version,
        nspname as schema
      FROM pg_extension e
      JOIN pg_namespace n ON e.extnamespace = n.oid
      ORDER BY extname
    `);
  }
}