/**
 * Oracle Database Adapter for RestifiedTS
 * 
 * Provides Oracle-specific database connectivity and operations using oracledb driver.
 */

import { 
  DatabaseAdapter, 
  DatabaseConfig, 
  DatabaseConnection, 
  ConnectionPool, 
  QueryBuilder,
  MigrationManager,
  DatabaseTestUtilities,
  QueryField
} from '../DatabaseTypes';

import { OracleConnection } from './connections/OracleConnection';
import { OracleConnectionPool } from './connections/OracleConnectionPool';
import { OracleQueryBuilder } from './builders/OracleQueryBuilder';
import { OracleMigrationManager } from './migrations/OracleMigrationManager';
import { OracleTestUtilities } from './testing/OracleTestUtilities';

export class OracleAdapter implements DatabaseAdapter {
  
  /**
   * Create a new Oracle connection
   */
  async connect(config: DatabaseConfig): Promise<DatabaseConnection> {
    if (config.type !== 'oracle') {
      throw new Error('Invalid database type for Oracle adapter');
    }

    const connection = new OracleConnection(config);
    await connection.connect();
    return connection;
  }

  /**
   * Create an Oracle connection pool
   */
  async createConnectionPool(config: DatabaseConfig): Promise<ConnectionPool> {
    if (config.type !== 'oracle') {
      throw new Error('Invalid database type for Oracle adapter');
    }

    const pool = new OracleConnectionPool(config);
    await pool.initialize();
    return pool;
  }

  /**
   * Create an Oracle query builder
   */
  createQueryBuilder(): QueryBuilder {
    return new OracleQueryBuilder();
  }

  /**
   * Create an Oracle migration manager
   */
  createMigrationManager(): MigrationManager {
    return new OracleMigrationManager();
  }

  /**
   * Create Oracle test utilities
   */
  createTestUtilities(): DatabaseTestUtilities {
    return new OracleTestUtilities();
  }

  /**
   * Escape Oracle identifier (table name, column name, etc.)
   */
  escapeIdentifier(identifier: string): string {
    return `"${identifier.replace(/"/g, '""')}"`;
  }

  /**
   * Escape Oracle value
   */
  escapeValue(value: any): string {
    if (value === null || value === undefined) {
      return 'NULL';
    }
    
    if (typeof value === 'string') {
      return `'${value.replace(/'/g, "''")}'`;
    }
    
    if (typeof value === 'number') {
      return value.toString();
    }
    
    if (typeof value === 'boolean') {
      return value ? '1' : '0';
    }
    
    if (value instanceof Date) {
      return `TO_DATE('${value.toISOString().slice(0, 19)}', 'YYYY-MM-DD"T"HH24:MI:SS')`;
    }
    
    if (Array.isArray(value)) {
      // Oracle doesn't have native array support in older versions
      return `'${JSON.stringify(value).replace(/'/g, "''")}'`;
    }
    
    return `'${JSON.stringify(value).replace(/'/g, "''")}'`;
  }

  /**
   * Build Oracle LIMIT clause (using ROWNUM or OFFSET/FETCH)
   */
  buildLimitClause(limit?: number, offset?: number): string {
    // Oracle 12c+ supports OFFSET/FETCH
    if (limit && offset) {
      return `OFFSET ${offset} ROWS FETCH NEXT ${limit} ROWS ONLY`;
    }
    
    if (limit) {
      return `FETCH FIRST ${limit} ROWS ONLY`;
    }
    
    if (offset) {
      return `OFFSET ${offset} ROWS`;
    }
    
    return '';
  }

  /**
   * Build Oracle LIMIT clause for older versions using ROWNUM
   */
  buildRownumLimitClause(limit?: number, offset?: number): string {
    if (!limit && !offset) {
      return '';
    }
    
    if (limit && offset) {
      return `WHERE ROWNUM > ${offset} AND ROWNUM <= ${offset + limit}`;
    }
    
    if (limit) {
      return `WHERE ROWNUM <= ${limit}`;
    }
    
    // Offset only with ROWNUM is complex and requires subquery
    return '';
  }

  /**
   * Get current timestamp in Oracle format
   */
  getCurrentTimestamp(): string {
    return 'SYSTIMESTAMP';
  }

  /**
   * Check if table exists
   */
  async tableExists(connection: DatabaseConnection, tableName: string): Promise<boolean> {
    const result = await connection.query(`
      SELECT COUNT(*) as count 
      FROM user_tables 
      WHERE UPPER(table_name) = UPPER(?)
    `, [tableName]);
    
    return result[0]?.count > 0;
  }

  /**
   * Get table columns information
   */
  async getTableColumns(connection: DatabaseConnection, tableName: string): Promise<QueryField[]> {
    const result = await connection.query(`
      SELECT 
        COLUMN_NAME as name,
        DATA_TYPE as type,
        NULLABLE as nullable,
        DATA_DEFAULT as default_value
      FROM user_tab_columns 
      WHERE UPPER(table_name) = UPPER(?)
      ORDER BY COLUMN_ID
    `, [tableName]);

    // Get primary key information
    const pkResult = await connection.query(`
      SELECT column_name
      FROM user_cons_columns ucc
      JOIN user_constraints uc ON ucc.constraint_name = uc.constraint_name
      WHERE uc.constraint_type = 'P'
      AND UPPER(uc.table_name) = UPPER(?)
    `, [tableName]);

    const primaryKeys = new Set(pkResult.map((row: any) => row.column_name.toUpperCase()));

    return result.map((row: any) => ({
      name: row.name,
      type: row.type,
      nullable: row.nullable === 'Y',
      primaryKey: primaryKeys.has(row.name.toUpperCase()),
      autoIncrement: false // Oracle uses sequences for auto-increment
    }));
  }

  /**
   * Get table indexes
   */
  async getTableIndexes(connection: DatabaseConnection, tableName: string): Promise<string[]> {
    const result = await connection.query(`
      SELECT DISTINCT index_name
      FROM user_indexes 
      WHERE UPPER(table_name) = UPPER(?)
      AND index_type != 'LOB'
      AND generated != 'Y'
    `, [tableName]);

    return result.map((row: any) => row.index_name);
  }

  /**
   * Get Oracle server version
   */
  async getServerVersion(connection: DatabaseConnection): Promise<string> {
    const result = await connection.query('SELECT * FROM v$version WHERE banner LIKE \'Oracle%\'');
    return result[0]?.banner || 'Unknown';
  }

  /**
   * Get database size in bytes
   */
  async getDatabaseSize(connection: DatabaseConnection): Promise<number> {
    const result = await connection.query(`
      SELECT SUM(bytes) as size_bytes
      FROM user_segments
    `);
    
    return parseInt(result[0]?.size_bytes || '0');
  }

  /**
   * Get table row count
   */
  async getTableRowCount(connection: DatabaseConnection, tableName: string): Promise<number> {
    const result = await connection.query(`SELECT COUNT(*) as count FROM ${this.escapeIdentifier(tableName)}`);
    return parseInt(result[0]?.count || '0');
  }

  /**
   * Analyze table for optimizer statistics
   */
  async analyzeTable(connection: DatabaseConnection, tableName: string): Promise<void> {
    await connection.query(`ANALYZE TABLE ${this.escapeIdentifier(tableName)} COMPUTE STATISTICS`);
  }

  /**
   * Get table statistics
   */
  async getTableStatistics(connection: DatabaseConnection, tableName: string): Promise<any> {
    const result = await connection.query(`
      SELECT 
        table_name,
        num_rows,
        blocks,
        empty_blocks,
        avg_space,
        chain_cnt,
        avg_row_len,
        last_analyzed
      FROM user_tables 
      WHERE UPPER(table_name) = UPPER(?)
    `, [tableName]);

    return result[0];
  }

  /**
   * Get active sessions
   */
  async getActiveSessions(connection: DatabaseConnection): Promise<any[]> {
    return await connection.query(`
      SELECT 
        sid,
        serial#,
        username,
        program,
        machine,
        osuser,
        logon_time,
        status,
        sql_id
      FROM v$session 
      WHERE type = 'USER'
      AND status = 'ACTIVE'
    `);
  }

  /**
   * Kill session
   */
  async killSession(connection: DatabaseConnection, sid: number, serial: number): Promise<void> {
    await connection.query(`ALTER SYSTEM KILL SESSION '${sid},${serial}'`);
  }

  /**
   * Create user
   */
  async createUser(connection: DatabaseConnection, username: string, password: string, options: any = {}): Promise<void> {
    let createQuery = `CREATE USER ${this.escapeIdentifier(username)} IDENTIFIED BY "${password}"`;
    
    if (options.defaultTablespace) {
      createQuery += ` DEFAULT TABLESPACE ${this.escapeIdentifier(options.defaultTablespace)}`;
    }
    
    if (options.temporaryTablespace) {
      createQuery += ` TEMPORARY TABLESPACE ${this.escapeIdentifier(options.temporaryTablespace)}`;
    }
    
    if (options.quota) {
      createQuery += ` QUOTA ${options.quota} ON ${this.escapeIdentifier(options.defaultTablespace || 'USERS')}`;
    }
    
    await connection.query(createQuery);
  }

  /**
   * Drop user
   */
  async dropUser(connection: DatabaseConnection, username: string, cascade: boolean = false): Promise<void> {
    const cascadeClause = cascade ? ' CASCADE' : '';
    await connection.query(`DROP USER ${this.escapeIdentifier(username)}${cascadeClause}`);
  }

  /**
   * Grant privileges
   */
  async grantPrivileges(
    connection: DatabaseConnection, 
    privileges: string, 
    objectName: string, 
    username: string
  ): Promise<void> {
    await connection.query(`GRANT ${privileges} ON ${this.escapeIdentifier(objectName)} TO ${this.escapeIdentifier(username)}`);
  }

  /**
   * Grant system privileges
   */
  async grantSystemPrivileges(
    connection: DatabaseConnection, 
    privileges: string[], 
    username: string
  ): Promise<void> {
    for (const privilege of privileges) {
      await connection.query(`GRANT ${privilege} TO ${this.escapeIdentifier(username)}`);
    }
  }

  /**
   * Create tablespace
   */
  async createTablespace(
    connection: DatabaseConnection, 
    tablespaceName: string, 
    dataFile: string,
    options: any = {}
  ): Promise<void> {
    let createQuery = `CREATE TABLESPACE ${this.escapeIdentifier(tablespaceName)} DATAFILE '${dataFile}'`;
    
    if (options.size) {
      createQuery += ` SIZE ${options.size}`;
    }
    
    if (options.autoextend) {
      createQuery += ` AUTOEXTEND ON`;
      if (options.next) {
        createQuery += ` NEXT ${options.next}`;
      }
      if (options.maxsize) {
        createQuery += ` MAXSIZE ${options.maxsize}`;
      }
    }
    
    await connection.query(createQuery);
  }

  /**
   * Drop tablespace
   */
  async dropTablespace(
    connection: DatabaseConnection, 
    tablespaceName: string, 
    includeContents: boolean = false
  ): Promise<void> {
    const includeClause = includeContents ? ' INCLUDING CONTENTS AND DATAFILES' : '';
    await connection.query(`DROP TABLESPACE ${this.escapeIdentifier(tablespaceName)}${includeClause}`);
  }

  /**
   * Get tablespaces information
   */
  async getTablespaces(connection: DatabaseConnection): Promise<any[]> {
    return await connection.query(`
      SELECT 
        tablespace_name,
        status,
        contents,
        logging,
        extent_management,
        allocation_type,
        segment_space_management
      FROM dba_tablespaces
      ORDER BY tablespace_name
    `);
  }

  /**
   * Create sequence
   */
  async createSequence(
    connection: DatabaseConnection, 
    sequenceName: string, 
    options: any = {}
  ): Promise<void> {
    let createQuery = `CREATE SEQUENCE ${this.escapeIdentifier(sequenceName)}`;
    
    if (options.startWith) {
      createQuery += ` START WITH ${options.startWith}`;
    }
    
    if (options.incrementBy) {
      createQuery += ` INCREMENT BY ${options.incrementBy}`;
    }
    
    if (options.minValue) {
      createQuery += ` MINVALUE ${options.minValue}`;
    }
    
    if (options.maxValue) {
      createQuery += ` MAXVALUE ${options.maxValue}`;
    }
    
    if (options.cache) {
      createQuery += ` CACHE ${options.cache}`;
    }
    
    if (options.cycle) {
      createQuery += ' CYCLE';
    }
    
    await connection.query(createQuery);
  }

  /**
   * Drop sequence
   */
  async dropSequence(connection: DatabaseConnection, sequenceName: string): Promise<void> {
    await connection.query(`DROP SEQUENCE ${this.escapeIdentifier(sequenceName)}`);
  }

  /**
   * Get sequence next value
   */
  async getSequenceNextValue(connection: DatabaseConnection, sequenceName: string): Promise<number> {
    const result = await connection.query(`SELECT ${this.escapeIdentifier(sequenceName)}.NEXTVAL as next_val FROM dual`);
    return parseInt(result[0]?.next_val || '0');
  }

  /**
   * Get sequence current value
   */
  async getSequenceCurrentValue(connection: DatabaseConnection, sequenceName: string): Promise<number> {
    const result = await connection.query(`SELECT ${this.escapeIdentifier(sequenceName)}.CURRVAL as curr_val FROM dual`);
    return parseInt(result[0]?.curr_val || '0');
  }

  /**
   * Execute PL/SQL block
   */
  async executePlSql(connection: DatabaseConnection, plsqlBlock: string): Promise<any> {
    return await connection.query(`BEGIN ${plsqlBlock} END;`);
  }

  /**
   * Create or replace procedure
   */
  async createProcedure(connection: DatabaseConnection, procedureName: string, procedureBody: string): Promise<void> {
    await connection.query(`CREATE OR REPLACE PROCEDURE ${this.escapeIdentifier(procedureName)} ${procedureBody}`);
  }

  /**
   * Drop procedure
   */
  async dropProcedure(connection: DatabaseConnection, procedureName: string): Promise<void> {
    await connection.query(`DROP PROCEDURE ${this.escapeIdentifier(procedureName)}`);
  }

  /**
   * Create or replace function
   */
  async createFunction(connection: DatabaseConnection, functionName: string, functionBody: string): Promise<void> {
    await connection.query(`CREATE OR REPLACE FUNCTION ${this.escapeIdentifier(functionName)} ${functionBody}`);
  }

  /**
   * Drop function
   */
  async dropFunction(connection: DatabaseConnection, functionName: string): Promise<void> {
    await connection.query(`DROP FUNCTION ${this.escapeIdentifier(functionName)}`);
  }

  /**
   * Get database parameters
   */
  async getDatabaseParameters(connection: DatabaseConnection, parameterName?: string): Promise<any[]> {
    let query = 'SELECT name, value, description FROM v$parameter';
    const params: any[] = [];
    
    if (parameterName) {
      query += ' WHERE UPPER(name) LIKE UPPER(?)';
      params.push(`%${parameterName}%`);
    }
    
    return await connection.query(query, params);
  }

  /**
   * Get database file information
   */
  async getDatabaseFiles(connection: DatabaseConnection): Promise<any[]> {
    return await connection.query(`
      SELECT 
        file_name,
        tablespace_name,
        bytes,
        status,
        autoextensible,
        maxbytes
      FROM dba_data_files
      ORDER BY tablespace_name, file_name
    `);
  }
}