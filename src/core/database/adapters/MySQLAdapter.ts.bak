/**
 * MySQL Database Adapter for RestifiedTS
 * 
 * Provides MySQL-specific database connectivity and operations using mysql2 driver.
 */

import { 
  DatabaseAdapter, 
  DatabaseConfig, 
  DatabaseConnection, 
  ConnectionPool, 
  QueryBuilder,
  MigrationManager,
  DatabaseTestUtilities,
  Transaction,
  PreparedStatement,
  DatabaseConnectionInfo,
  QueryField,
  DatabaseError
} from '../DatabaseTypes';

import { MySQLConnection } from './connections/MySQLConnection';
import { MySQLConnectionPool } from './connections/MySQLConnectionPool';
import { MySQLQueryBuilder } from './builders/MySQLQueryBuilder';
import { MySQLMigrationManager } from './migrations/MySQLMigrationManager';
import { MySQLTestUtilities } from './testing/MySQLTestUtilities';

export class MySQLAdapter implements DatabaseAdapter {
  
  /**
   * Create a new MySQL connection
   */
  async connect(config: DatabaseConfig): Promise<DatabaseConnection> {
    if (config.type !== 'mysql') {
      throw new Error('Invalid database type for MySQL adapter');
    }

    const connection = new MySQLConnection(config);
    await connection.connect();
    return connection;
  }

  /**
   * Create a MySQL connection pool
   */
  async createConnectionPool(config: DatabaseConfig): Promise<ConnectionPool> {
    if (config.type !== 'mysql') {
      throw new Error('Invalid database type for MySQL adapter');
    }

    const pool = new MySQLConnectionPool(config);
    await pool.initialize();
    return pool;
  }

  /**
   * Create a MySQL query builder
   */
  createQueryBuilder(): QueryBuilder {
    return new MySQLQueryBuilder();
  }

  /**
   * Create a MySQL migration manager
   */
  createMigrationManager(): MigrationManager {
    return new MySQLMigrationManager();
  }

  /**
   * Create MySQL test utilities
   */
  createTestUtilities(): DatabaseTestUtilities {
    return new MySQLTestUtilities();
  }

  /**
   * Escape MySQL identifier (table name, column name, etc.)
   */
  escapeIdentifier(identifier: string): string {
    return `\`${identifier.replace(/`/g, '``')}\``;
  }

  /**
   * Escape MySQL value
   */
  escapeValue(value: any): string {
    if (value === null || value === undefined) {
      return 'NULL';
    }
    
    if (typeof value === 'string') {
      return `'${value.replace(/'/g, "''")}'`;
    }
    
    if (typeof value === 'number') {
      return value.toString();
    }
    
    if (typeof value === 'boolean') {
      return value ? '1' : '0';
    }
    
    if (value instanceof Date) {
      return `'${value.toISOString().slice(0, 19).replace('T', ' ')}'`;
    }
    
    if (Array.isArray(value)) {
      return `(${value.map(v => this.escapeValue(v)).join(', ')})`;
    }
    
    return `'${JSON.stringify(value).replace(/'/g, "''")}'`;
  }

  /**
   * Build MySQL LIMIT clause
   */
  buildLimitClause(limit?: number, offset?: number): string {
    if (!limit && !offset) {
      return '';
    }
    
    if (limit && offset) {
      return `LIMIT ${offset}, ${limit}`;
    }
    
    if (limit) {
      return `LIMIT ${limit}`;
    }
    
    if (offset) {
      return `LIMIT ${offset}, 18446744073709551615`; // MySQL max value
    }
    
    return '';
  }

  /**
   * Get current timestamp in MySQL format
   */
  getCurrentTimestamp(): string {
    return 'NOW()';
  }

  /**
   * Check if table exists
   */
  async tableExists(connection: DatabaseConnection, tableName: string): Promise<boolean> {
    const result = await connection.query(`
      SELECT COUNT(*) as count 
      FROM information_schema.tables 
      WHERE table_schema = DATABASE() 
      AND table_name = ?
    `, [tableName]);
    
    return result[0]?.count > 0;
  }

  /**
   * Get table columns information
   */
  async getTableColumns(connection: DatabaseConnection, tableName: string): Promise<QueryField[]> {
    const result = await connection.query(`
      SELECT 
        COLUMN_NAME as name,
        DATA_TYPE as type,
        IS_NULLABLE as nullable,
        COLUMN_KEY as key_type,
        EXTRA as extra
      FROM information_schema.columns 
      WHERE table_schema = DATABASE() 
      AND table_name = ?
      ORDER BY ORDINAL_POSITION
    `, [tableName]);

    return result.map((row: any) => ({
      name: row.name,
      type: row.type,
      nullable: row.nullable === 'YES',
      primaryKey: row.key_type === 'PRI',
      autoIncrement: row.extra.includes('auto_increment')
    }));
  }

  /**
   * Get table indexes
   */
  async getTableIndexes(connection: DatabaseConnection, tableName: string): Promise<string[]> {
    const result = await connection.query(`
      SELECT DISTINCT INDEX_NAME as index_name
      FROM information_schema.statistics 
      WHERE table_schema = DATABASE() 
      AND table_name = ?
      AND INDEX_NAME != 'PRIMARY'
    `, [tableName]);

    return result.map((row: any) => row.index_name);
  }

  /**
   * Create database if not exists
   */
  async createDatabase(connection: DatabaseConnection, databaseName: string): Promise<void> {
    await connection.query(`CREATE DATABASE IF NOT EXISTS ${this.escapeIdentifier(databaseName)}`);
  }

  /**
   * Drop database if exists
   */
  async dropDatabase(connection: DatabaseConnection, databaseName: string): Promise<void> {
    await connection.query(`DROP DATABASE IF EXISTS ${this.escapeIdentifier(databaseName)}`);
  }

  /**
   * Get MySQL server version
   */
  async getServerVersion(connection: DatabaseConnection): Promise<string> {
    const result = await connection.query('SELECT VERSION() as version');
    return result[0]?.version || 'Unknown';
  }

  /**
   * Get database size in bytes
   */
  async getDatabaseSize(connection: DatabaseConnection, databaseName?: string): Promise<number> {
    const dbName = databaseName || 'DATABASE()';
    const result = await connection.query(`
      SELECT 
        SUM(data_length + index_length) as size_bytes
      FROM information_schema.tables 
      WHERE table_schema = ${typeof dbName === 'string' && !dbName.includes('(') ? `'${dbName}'` : dbName}
    `);
    
    return parseInt(result[0]?.size_bytes || '0');
  }

  /**
   * Get table row count
   */
  async getTableRowCount(connection: DatabaseConnection, tableName: string): Promise<number> {
    const result = await connection.query(`SELECT COUNT(*) as count FROM ${this.escapeIdentifier(tableName)}`);
    return parseInt(result[0]?.count || '0');
  }

  /**
   * Optimize table
   */
  async optimizeTable(connection: DatabaseConnection, tableName: string): Promise<void> {
    await connection.query(`OPTIMIZE TABLE ${this.escapeIdentifier(tableName)}`);
  }

  /**
   * Analyze table
   */
  async analyzeTable(connection: DatabaseConnection, tableName: string): Promise<void> {
    await connection.query(`ANALYZE TABLE ${this.escapeIdentifier(tableName)}`);
  }

  /**
   * Get connection charset and collation
   */
  async getConnectionCharset(connection: DatabaseConnection): Promise<{ charset: string; collation: string }> {
    const result = await connection.query(`
      SELECT 
        @@character_set_connection as charset,
        @@collation_connection as collation
    `);
    
    return {
      charset: result[0]?.charset || 'utf8mb4',
      collation: result[0]?.collation || 'utf8mb4_unicode_ci'
    };
  }

  /**
   * Set connection charset
   */
  async setConnectionCharset(connection: DatabaseConnection, charset: string = 'utf8mb4'): Promise<void> {
    await connection.query(`SET NAMES ${charset}`);
  }

  /**
   * Get process list (active connections)
   */
  async getProcessList(connection: DatabaseConnection): Promise<any[]> {
    return await connection.query('SHOW PROCESSLIST');
  }

  /**
   * Kill connection by process ID
   */
  async killConnection(connection: DatabaseConnection, processId: number): Promise<void> {
    await connection.query(`KILL ${processId}`);
  }

  /**
   * Create user
   */
  async createUser(connection: DatabaseConnection, username: string, password: string, host: string = '%'): Promise<void> {
    await connection.query(`CREATE USER '${username}'@'${host}' IDENTIFIED BY '${password}'`);
  }

  /**
   * Drop user
   */
  async dropUser(connection: DatabaseConnection, username: string, host: string = '%'): Promise<void> {
    await connection.query(`DROP USER IF EXISTS '${username}'@'${host}'`);
  }

  /**
   * Grant privileges
   */
  async grantPrivileges(
    connection: DatabaseConnection, 
    privileges: string, 
    database: string, 
    username: string, 
    host: string = '%'
  ): Promise<void> {
    await connection.query(`GRANT ${privileges} ON ${database}.* TO '${username}'@'${host}'`);
    await connection.query('FLUSH PRIVILEGES');
  }

  /**
   * Show grants for user
   */
  async showGrants(connection: DatabaseConnection, username: string, host: string = '%'): Promise<string[]> {
    const result = await connection.query(`SHOW GRANTS FOR '${username}'@'${host}'`);
    return result.map((row: any) => Object.values(row)[0] as string);
  }
}