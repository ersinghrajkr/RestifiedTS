// src/decorators/TestTags.ts

import 'reflect-metadata';
import { TestMetadata } from './TestMetadata';

/**
 * Production-grade decorator system for test tagging and metadata management
 * 
 * Features:
 * - Built-in decorators for common test categorization (@smoke, @regression, etc.)
 * - Custom tag creation with @tag decorator
 * - Test metadata storage and retrieval
 * - Tag-based filtering capabilities
 * - Test execution control based on tags
 * - Performance and priority management
 * - Tag inheritance and composition
 * 
 * @example
 * ```typescript
 * class UserAPITests {
 *   @smoke
 *   @critical
 *   @tag('user-management')
 *   async testUserLogin() {
 *     await restified
 *       .given()
 *       .when()
 *         .post('/auth/login', credentials)
 *         .execute()
 *       .then()
 *         .statusCode(200);
 *   }
 * 
 *   @regression
 *   @slow
 *   @tag('data-validation')
 *   async testUserProfileValidation() {
 *     // Test implementation
 *   }
 * }
 * ```
 */

// Metadata keys for storing test information
const TAGS_METADATA_KEY = Symbol('restified:tags');
const TEST_METADATA_KEY = Symbol('restified:test-metadata');
const TIMEOUT_METADATA_KEY = Symbol('restified:timeout');
const RETRY_METADATA_KEY = Symbol('restified:retry');
const PRIORITY_METADATA_KEY = Symbol('restified:priority');
const SKIP_METADATA_KEY = Symbol('restified:skip');

/**
 * Built-in smoke test decorator
 * Marks tests as smoke tests for quick validation
 */
export function smoke(target: any, propertyKey: string, descriptor: PropertyDescriptor): void {
  addTag(target, propertyKey, 'smoke');
  setPriority(target, propertyKey, 100); // High priority for smoke tests
  setTestMetadata(target, propertyKey, {
    category: 'smoke',
    description: 'Smoke test for critical functionality',
    autoGenerated: true
  });
}

/**
 * Built-in regression test decorator
 * Marks tests as regression tests for comprehensive validation
 */
export function regression(target: any, propertyKey: string, descriptor: PropertyDescriptor): void {
  addTag(target, propertyKey, 'regression');
  setPriority(target, propertyKey, 50); // Medium priority for regression tests
  setTestMetadata(target, propertyKey, {
    category: 'regression',
    description: 'Regression test for existing functionality',
    autoGenerated: true
  });
}

/**
 * Built-in integration test decorator
 * Marks tests as integration tests
 */
export function integration(target: any, propertyKey: string, descriptor: PropertyDescriptor): void {
  addTag(target, propertyKey, 'integration');
  setPriority(target, propertyKey, 30);
  setTestMetadata(target, propertyKey, {
    category: 'integration',
    description: 'Integration test for component interaction',
    autoGenerated: true
  });
}

/**
 * Built-in unit test decorator
 * Marks tests as unit tests
 */
export function unit(target: any, propertyKey: string, descriptor: PropertyDescriptor): void {
  addTag(target, propertyKey, 'unit');
  setPriority(target, propertyKey, 20);
  setTestMetadata(target, propertyKey, {
    category: 'unit',
    description: 'Unit test for isolated functionality',
    autoGenerated: true
  });
}

/**
 * Built-in end-to-end test decorator
 * Marks tests as e2e tests
 */
export function e2e(target: any, propertyKey: string, descriptor: PropertyDescriptor): void {
  addTag(target, propertyKey, 'e2e');
  setPriority(target, propertyKey, 10); // Lower priority due to longer execution time
  setTestMetadata(target, propertyKey, {
    category: 'e2e',
    description: 'End-to-end test for complete user journey',
    autoGenerated: true
  });
}

/**
 * Critical test decorator
 * Marks tests as critical for business functionality
 */
export function critical(target: any, propertyKey: string, descriptor: PropertyDescriptor): void {
  addTag(target, propertyKey, 'critical');
  setPriority(target, propertyKey, 200); // Very high priority
  setTestMetadata(target, propertyKey, {
    criticality: 'high',
    description: 'Critical test that must pass',
    autoGenerated: true
  });
}

/**
 * Slow test decorator
 * Marks tests as slow-running
 */
export function slow(target: any, propertyKey: string, descriptor: PropertyDescriptor): void {
  addTag(target, propertyKey, 'slow');
  setTimeout(target, propertyKey, 30000); // 30 second timeout for slow tests
  setTestMetadata(target, propertyKey, {
    performance: 'slow',
    description: 'Slow-running test with extended timeout',
    autoGenerated: true
  });
}

/**
 * Fast test decorator
 * Marks tests as fast-running
 */
export function fast(target: any, propertyKey: string, descriptor: PropertyDescriptor): void {
  addTag(target, propertyKey, 'fast');
  setTimeout(target, propertyKey, 5000); // 5 second timeout for fast tests
  setTestMetadata(target, propertyKey, {
    performance: 'fast',
    description: 'Fast-running test with short timeout',
    autoGenerated: true
  });
}

/**
 * Flaky test decorator
 * Marks tests as potentially flaky with retry configuration
 */
export function flaky(retries: number = 3): PropertyDecorator {
  return function(target: any, propertyKey: string | symbol): void {
    addTag(target, propertyKey as string, 'flaky');
    setRetries(target, propertyKey as string, retries);
    setTestMetadata(target, propertyKey as string, {
      stability: 'flaky',
      retries,
      description: `Flaky test with ${retries} retry attempts`,
      autoGenerated: true
    });
  };
}

/**
 * Skip test decorator
 * Marks tests to be skipped with optional reason
 */
export function skip(reason?: string): PropertyDecorator {
  return function(target: any, propertyKey: string | symbol): void {
    addTag(target, propertyKey as string, 'skip');
    setSkipped(target, propertyKey as string, true, reason);
    setTestMetadata(target, propertyKey as string, {
      skipped: true,
      skipReason: reason,
      description: `Skipped test: ${reason || 'No reason provided'}`,
      autoGenerated: true
    });
  };
}

/**
 * Custom tag decorator
 * Allows adding custom tags to tests
 */
export function tag(tagName: string): PropertyDecorator {
  return function(target: any, propertyKey: string | symbol): void {
    validateTagName(tagName);
    addTag(target, propertyKey as string, tagName);
  };
}

/**
 * Multiple tags decorator
 * Allows adding multiple tags at once
 */
export function tags(...tagNames: string[]): PropertyDecorator {
  return function(target: any, propertyKey: string | symbol): void {
    tagNames.forEach(tagName => {
      validateTagName(tagName);
      addTag(target, propertyKey as string, tagName);
    });
  };
}

/**
 * Test description decorator
 * Adds descriptive information to tests
 */
export function description(desc: string): PropertyDecorator {
  return function(target: any, propertyKey: string | symbol): void {
    setTestMetadata(target, propertyKey as string, {
      description: desc,
      userProvided: true
    });
  };
}

/**
 * Test timeout decorator
 * Sets custom timeout for specific tests
 */
export function timeout(ms: number): PropertyDecorator {
  return function(target: any, propertyKey: string | symbol): void {
    validateTimeout(ms);
    setTimeout(target, propertyKey as string, ms);
  };
}

/**
 * Test retry decorator
 * Sets retry configuration for specific tests
 */
export function retry(attempts: number): PropertyDecorator {
  return function(target: any, propertyKey: string | symbol): void {
    validateRetryAttempts(attempts);
    setRetries(target, propertyKey as string, attempts);
  };
}

/**
 * Test priority decorator
 * Sets execution priority for tests
 */
export function priority(level: number): PropertyDecorator {
  return function(target: any, propertyKey: string | symbol): void {
    validatePriority(level);
    setPriority(target, propertyKey as string, level);
  };
}

/**
 * Test author decorator
 * Records test author information
 */
export function author(name: string, email?: string): PropertyDecorator {
  return function(target: any, propertyKey: string | symbol): void {
    setTestMetadata(target, propertyKey as string, {
      author: { name, email },
      userProvided: true
    });
  };
}

/**
 * Test issue tracker decorator
 * Links tests to issue tracking systems
 */
export function issue(issueId: string, url?: string): PropertyDecorator {
  return function(target: any, propertyKey: string | symbol): void {
    setTestMetadata(target, propertyKey as string, {
      issue: { id: issueId, url },
      userProvided: true
    });
  };
}

/**
 * Test dependency decorator
 * Marks test dependencies on other tests or services
 */
export function dependsOn(...dependencies: string[]): PropertyDecorator {
  return function(target: any, propertyKey: string | symbol): void {
    setTestMetadata(target, propertyKey as string, {
      dependencies,
      userProvided: true
    });
  };
}

/**
 * Test group decorator
 * Groups related tests together
 */
export function group(groupName: string): PropertyDecorator {
  return function(target: any, propertyKey: string | symbol): void {
    addTag(target, propertyKey as string, `group:${groupName}`);
    setTestMetadata(target, propertyKey as string, {
      group: groupName,
      userProvided: true
    });
  };
}

/**
 * Environment-specific test decorator
 * Marks tests to run only in specific environments
 */
export function env(...environments: string[]): PropertyDecorator {
  return function(target: any, propertyKey: string | symbol): void {
    environments.forEach(environment => {
      addTag(target, propertyKey as string, `env:${environment}`);
    });
    setTestMetadata(target, propertyKey as string, {
      environments,
      userProvided: true
    });
  };
}

/**
 * Feature toggle decorator
 * Marks tests that require specific feature flags
 */
export function feature(featureName: string): PropertyDecorator {
  return function(target: any, propertyKey: string | symbol): void {
    addTag(target, propertyKey as string, `feature:${featureName}`);
    setTestMetadata(target, propertyKey as string, {
      requiredFeature: featureName,
      userProvided: true
    });
  };
}

// ==========================================
// UTILITY FUNCTIONS
// ==========================================

/**
 * Add a tag to a test method
 */
function addTag(target: any, propertyKey: string, tagName: string): void {
  const existingTags = Reflect.getMetadata(TAGS_METADATA_KEY, target, propertyKey) || [];
  const updatedTags = [...new Set([...existingTags, tagName])]; // Remove duplicates
  Reflect.defineMetadata(TAGS_METADATA_KEY, updatedTags, target, propertyKey);
}

/**
 * Set timeout for a test method
 */
function setTimeout(target: any, propertyKey: string, ms: number): void {
  Reflect.defineMetadata(TIMEOUT_METADATA_KEY, ms, target, propertyKey);
}

/**
 * Set retry attempts for a test method
 */
function setRetries(target: any, propertyKey: string, attempts: number): void {
  Reflect.defineMetadata(RETRY_METADATA_KEY, attempts, target, propertyKey);
}

/**
 * Set priority for a test method
 */
function setPriority(target: any, propertyKey: string, level: number): void {
  Reflect.defineMetadata(PRIORITY_METADATA_KEY, level, target, propertyKey);
}

/**
 * Set skip status for a test method
 */
function setSkipped(target: any, propertyKey: string, skipped: boolean, reason?: string): void {
  Reflect.defineMetadata(SKIP_METADATA_KEY, { skipped, reason }, target, propertyKey);
}

/**
 * Set test metadata
 */
function setTestMetadata(target: any, propertyKey: string, metadata: Partial<TestMetadata>): void {
  const existingMetadata = Reflect.getMetadata(TEST_METADATA_KEY, target, propertyKey) || {};
  const updatedMetadata = { ...existingMetadata, ...metadata };
  Reflect.defineMetadata(TEST_METADATA_KEY, updatedMetadata, target, propertyKey);
}

// ==========================================
// METADATA RETRIEVAL FUNCTIONS
// ==========================================

/**
 * Get all tags for a test method
 */
export function getTags(target: any, propertyKey: string): string[] {
  return Reflect.getMetadata(TAGS_METADATA_KEY, target, propertyKey) || [];
}

/**
 * Get timeout for a test method
 */
export function getTimeout(target: any, propertyKey: string): number | undefined {
  return Reflect.getMetadata(TIMEOUT_METADATA_KEY, target, propertyKey);
}

/**
 * Get retry attempts for a test method
 */
export function getRetries(target: any, propertyKey: string): number | undefined {
  return Reflect.getMetadata(RETRY_METADATA_KEY, target, propertyKey);
}

/**
 * Get priority for a test method
 */
export function getPriority(target: any, propertyKey: string): number | undefined {
  return Reflect.getMetadata(PRIORITY_METADATA_KEY, target, propertyKey);
}

/**
 * Get skip information for a test method
 */
export function getSkipInfo(target: any, propertyKey: string): { skipped: boolean; reason?: string } | undefined {
  return Reflect.getMetadata(SKIP_METADATA_KEY, target, propertyKey);
}

/**
 * Get complete test metadata
 */
export function getTestMetadata(target: any, propertyKey: string): TestMetadata {
  const baseMetadata = Reflect.getMetadata(TEST_METADATA_KEY, target, propertyKey) || {};
  const tags = getTags(target, propertyKey);
  const timeout = getTimeout(target, propertyKey);
  const retries = getRetries(target, propertyKey);
  const priority = getPriority(target, propertyKey);
  const skipInfo = getSkipInfo(target, propertyKey);

  return {
    tags,
    timeout,
    retries,
    priority,
    skipped: skipInfo?.skipped || false,
    skipReason: skipInfo?.reason,
    ...baseMetadata
  };
}

/**
 * Check if a test has a specific tag
 */
export function hasTag(target: any, propertyKey: string, tagName: string): boolean {
  const tags = getTags(target, propertyKey);
  return tags.includes(tagName);
}

/**
 * Check if a test has any of the specified tags
 */
export function hasAnyTag(target: any, propertyKey: string, tagNames: string[]): boolean {
  const tags = getTags(target, propertyKey);
  return tagNames.some(tagName => tags.includes(tagName));
}

/**
 * Check if a test has all of the specified tags
 */
export function hasAllTags(target: any, propertyKey: string, tagNames: string[]): boolean {
  const tags = getTags(target, propertyKey);
  return tagNames.every(tagName => tags.includes(tagName));
}

/**
 * Get all test methods from a class with their metadata
 */
export function getTestMethods(targetClass: any): TestMethodInfo[] {
  const prototype = targetClass.prototype;
  const methodNames = Object.getOwnPropertyNames(prototype)
    .filter(name => name !== 'constructor' && typeof prototype[name] === 'function');

  return methodNames.map(methodName => ({
    methodName,
    className: targetClass.name,
    metadata: getTestMetadata(prototype, methodName),
    isTest: getTags(prototype, methodName).length > 0 || 
            getTestMetadata(prototype, methodName).description !== undefined
  })).filter(info => info.isTest);
}

/**
 * Filter test methods by tags
 */
export function filterTestsByTags(
  testMethods: TestMethodInfo[], 
  includeTags: string[] = [], 
  excludeTags: string[] = []
): TestMethodInfo[] {
  return testMethods.filter(testMethod => {
    const tags = testMethod.metadata.tags || [];
    
    // Check include tags
    if (includeTags.length > 0 && !hasAnyTag(testMethod, testMethod.methodName, includeTags)) {
      return false;
    }
    
    // Check exclude tags
    if (excludeTags.length > 0 && hasAnyTag(testMethod, testMethod.methodName, excludeTags)) {
      return false;
    }
    
    return true;
  });
}

/**
 * Sort test methods by priority (higher priority first)
 */
export function sortTestsByPriority(testMethods: TestMethodInfo[]): TestMethodInfo[] {
  return [...testMethods].sort((a, b) => {
    const priorityA = a.metadata.priority || 0;
    const priorityB = b.metadata.priority || 0;
    return priorityB - priorityA; // Higher priority first
  });
}

/**
 * Group test methods by tag
 */
export function groupTestsByTag(testMethods: TestMethodInfo[]): Map<string, TestMethodInfo[]> {
  const groups = new Map<string, TestMethodInfo[]>();
  
  testMethods.forEach(testMethod => {
    const tags = testMethod.metadata.tags || [];
    tags.forEach(tag => {
      if (!groups.has(tag)) {
        groups.set(tag, []);
      }
      groups.get(tag)!.push(testMethod);
    });
  });
  
  return groups;
}

// ==========================================
// VALIDATION FUNCTIONS
// ==========================================

function validateTagName(tagName: string): void {
  if (typeof tagName !== 'string' || tagName.trim() === '') {
    throw new Error('Tag name must be a non-empty string');
  }
  
  if (!/^[a-zA-Z0-9_-]+$/.test(tagName)) {
    throw new Error('Tag name must contain only alphanumeric characters, underscores, and hyphens');
  }
  
  if (tagName.length > 50) {
    throw new Error('Tag name must be 50 characters or less');
  }
}

function validateTimeout(ms: number): void {
  if (typeof ms !== 'number' || ms <= 0 || !Number.isInteger(ms)) {
    throw new Error('Timeout must be a positive integer');
  }
  
  if (ms > 300000) { // 5 minutes
    console.warn(`Warning: timeout value ${ms}ms is very high (>5 minutes)`);
  }
}

function validateRetryAttempts(attempts: number): void {
  if (typeof attempts !== 'number' || attempts < 0 || !Number.isInteger(attempts)) {
    throw new Error('Retry attempts must be a non-negative integer');
  }
  
  if (attempts > 10) {
    console.warn(`Warning: retry attempts ${attempts} is very high (>10)`);
  }
}

function validatePriority(level: number): void {
  if (typeof level !== 'number' || !Number.isInteger(level)) {
    throw new Error('Priority must be an integer');
  }
}

// ==========================================
// INTERFACES AND TYPES
// ==========================================

export interface TestMethodInfo {
  methodName: string;
  className: string;
  metadata: TestMetadata;
  isTest: boolean;
}

export interface TagFilterOptions {
  includeTags?: string[];
  excludeTags?: string[];
  includeSkipped?: boolean;
  sortByPriority?: boolean;
}

export interface TestExecutionPlan {
  testMethods: TestMethodInfo[];
  totalTests: number;
  estimatedDuration: number;
  groupedByTag: Map<string, TestMethodInfo[]>;
  priorityLevels: Map<number, TestMethodInfo[]>;
}