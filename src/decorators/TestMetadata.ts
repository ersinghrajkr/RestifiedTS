// src/decorators/TestMetadata.ts

/**
 * Comprehensive test metadata management system
 * 
 * Features:
 * - Rich metadata storage for test methods
 * - Test execution context and history
 * - Performance tracking and analysis
 * - Test relationship mapping
 * - Metadata serialization and persistence
 * - Test discovery and introspection
 * 
 * @example
 * ```typescript
 * const metadata: TestMetadata = {
 *   tags: ['smoke', 'critical'],
 *   description: 'User authentication flow validation',
 *   timeout: 5000,
 *   retries: 2,
 *   priority: 100,
 *   author: { name: 'John Doe', email: 'john@example.com' },
 *   issue: { id: 'JIRA-123', url: 'https://jira.company.com/JIRA-123' }
 * };
 * ```
 */

/**
 * Core test metadata interface
 */
export interface TestMetadata {
  // Basic test information
  tags?: string[];
  description?: string;
  timeout?: number;
  retries?: number;
  priority?: number;
  
  // Test categorization
  category?: string;
  group?: string;
  suite?: string;
  
  // Test status and execution
  skipped?: boolean;
  skipReason?: string;
  disabled?: boolean;
  disabledReason?: string;
  
  // Performance characteristics
  performance?: 'fast' | 'medium' | 'slow';
  expectedDuration?: number;
  
  // Test stability
  stability?: 'stable' | 'flaky' | 'unstable';
  flakyReason?: string;
  
  // Environment and feature requirements
  environments?: string[];
  requiredFeature?: string;
  requiredFeatures?: string[];
  
  // Test relationships
  dependencies?: string[];
  dependents?: string[];
  prerequisites?: string[];
  
  // Documentation and tracking
  author?: TestAuthor;
  issue?: TestIssue;
  documentation?: TestDocumentation;
  
  // Execution history and statistics
  executionHistory?: TestExecutionRecord[];
  statistics?: TestStatistics;
  
  // Custom metadata
  customData?: Record<string, any>;
  
  // Internal metadata
  autoGenerated?: boolean;
  userProvided?: boolean;
  lastModified?: Date;
  version?: string;
}

/**
 * Test author information
 */
export interface TestAuthor {
  name: string;
  email?: string;
  team?: string;
  role?: string;
}

/**
 * Test issue tracking information
 */
export interface TestIssue {
  id: string;
  url?: string;
  type?: 'bug' | 'feature' | 'story' | 'task';
  status?: string;
  priority?: 'low' | 'medium' | 'high' | 'critical';
}

/**
 * Test documentation links and references
 */
export interface TestDocumentation {
  specUrl?: string;
  wikiUrl?: string;
  requirementsUrl?: string;
  designDocUrl?: string;
  testPlanUrl?: string;
  notes?: string[];
}

/**
 * Test execution record
 */
export interface TestExecutionRecord {
  timestamp: Date;
  duration: number;
  result: 'pass' | 'fail' | 'skip' | 'error';
  error?: string;
  environment?: string;
  version?: string;
  metadata?: Record<string, any>;
}

/**
 * Test execution statistics
 */
export interface TestStatistics {
  totalExecutions: number;
  passCount: number;
  failCount: number;
  skipCount: number;
  errorCount: number;
  averageDuration: number;
  minDuration: number;
  maxDuration: number;
  successRate: number;
  flakyScore: number;
  lastExecution?: Date;
  firstExecution?: Date;
}

/**
 * Test metadata manager class
 */
export class TestMetadataManager {
  private static instance: TestMetadataManager;
  private metadataStore: Map<string, TestMetadata> = new Map();
  private executionHistory: Map<string, TestExecutionRecord[]> = new Map();
  private readonly maxHistoryEntries: number = 100;

  private constructor() {}

  /**
   * Get singleton instance
   */
  static getInstance(): TestMetadataManager {
    if (!TestMetadataManager.instance) {
      TestMetadataManager.instance = new TestMetadataManager();
    }
    return TestMetadataManager.instance;
  }

  /**
   * Register test metadata
   */
  registerTestMetadata(testId: string, metadata: TestMetadata): void {
    this.validateTestId(testId);
    this.validateMetadata(metadata);
    
    const existingMetadata = this.metadataStore.get(testId) || {};
    const mergedMetadata: TestMetadata = {
      ...existingMetadata,
      ...metadata,
      lastModified: new Date(),
      version: this.generateVersion(existingMetadata.version)
    };
    
    this.metadataStore.set(testId, mergedMetadata);
  }

  /**
   * Get test metadata
   */
  getTestMetadata(testId: string): TestMetadata | undefined {
    return this.metadataStore.get(testId);
  }

  /**
   * Update test metadata
   */
  updateTestMetadata(testId: string, updates: Partial<TestMetadata>): void {
    const existing = this.metadataStore.get(testId);
    if (!existing) {
      throw new Error(`Test metadata not found for ID: ${testId}`);
    }
    
    this.registerTestMetadata(testId, { ...existing, ...updates });
  }

  /**
   * Remove test metadata
   */
  removeTestMetadata(testId: string): boolean {
    const removed = this.metadataStore.delete(testId);
    if (removed) {
      this.executionHistory.delete(testId);
    }
    return removed;
  }

  /**
   * Record test execution
   */
  recordExecution(testId: string, record: TestExecutionRecord): void {
    if (!this.executionHistory.has(testId)) {
      this.executionHistory.set(testId, []);
    }
    
    const history = this.executionHistory.get(testId)!;
    history.push(record);
    
    // Maintain history size limit
    if (history.length > this.maxHistoryEntries) {
      history.shift();
    }
    
    // Update test metadata with execution info
    this.updateExecutionStatistics(testId, record);
  }

  /**
   * Get test execution history
   */
  getExecutionHistory(testId: string): TestExecutionRecord[] {
    return this.executionHistory.get(testId) || [];
  }

  /**
   * Get test statistics
   */
  getTestStatistics(testId: string): TestStatistics | undefined {
    const metadata = this.metadataStore.get(testId);
    return metadata?.statistics;
  }

  /**
   * Find tests by tags
   */
  findTestsByTags(tags: string[], matchAll: boolean = false): Map<string, TestMetadata> {
    const results = new Map<string, TestMetadata>();
    
    this.metadataStore.forEach((metadata, testId) => {
      const testTags = metadata.tags || [];
      const hasMatchingTags = matchAll 
        ? tags.every(tag => testTags.includes(tag))
        : tags.some(tag => testTags.includes(tag));
      
      if (hasMatchingTags) {
        results.set(testId, metadata);
      }
    });
    
    return results;
  }

  /**
   * Find tests by category
   */
  findTestsByCategory(category: string): Map<string, TestMetadata> {
    const results = new Map<string, TestMetadata>();
    
    this.metadataStore.forEach((metadata, testId) => {
      if (metadata.category === category) {
        results.set(testId, metadata);
      }
    });
    
    return results;
  }

  /**
   * Find tests by author
   */
  findTestsByAuthor(authorName: string): Map<string, TestMetadata> {
    const results = new Map<string, TestMetadata>();
    
    this.metadataStore.forEach((metadata, testId) => {
      if (metadata.author?.name === authorName) {
        results.set(testId, metadata);
      }
    });
    
    return results;
  }

  /**
   * Find flaky tests
   */
  findFlakyTests(threshold: number = 0.8): Map<string, TestMetadata> {
    const results = new Map<string, TestMetadata>();
    
    this.metadataStore.forEach((metadata, testId) => {
      const stats = metadata.statistics;
      if (stats && stats.flakyScore > threshold) {
        results.set(testId, metadata);
      }
    });
    
    return results;
  }

  /**
   * Find slow tests
   */
  findSlowTests(durationThreshold: number = 10000): Map<string, TestMetadata> {
    const results = new Map<string, TestMetadata>();
    
    this.metadataStore.forEach((metadata, testId) => {
      const stats = metadata.statistics;
      if (stats && stats.averageDuration > durationThreshold) {
        results.set(testId, metadata);
      }
    });
    
    return results;
  }

  /**
   * Find tests with low success rate
   */
  findUnreliableTests(successRateThreshold: number = 0.9): Map<string, TestMetadata> {
    const results = new Map<string, TestMetadata>();
    
    this.metadataStore.forEach((metadata, testId) => {
      const stats = metadata.statistics;
      if (stats && stats.successRate < successRateThreshold) {
        results.set(testId, metadata);
      }
    });
    
    return results;
  }

  /**
   * Get test dependency graph
   */
  getDependencyGraph(): Map<string, string[]> {
    const graph = new Map<string, string[]>();
    
    this.metadataStore.forEach((metadata, testId) => {
      if (metadata.dependencies && metadata.dependencies.length > 0) {
        graph.set(testId, metadata.dependencies);
      }
    });
    
    return graph;
  }

  /**
   * Validate test execution order based on dependencies
   */
  validateExecutionOrder(testIds: string[]): { valid: boolean; issues: string[] } {
    const issues: string[] = [];
    const graph = this.getDependencyGraph();
    const executed = new Set<string>();
    
    for (const testId of testIds) {
      const dependencies = graph.get(testId) || [];
      
      for (const dependency of dependencies) {
        if (!executed.has(dependency) && testIds.includes(dependency)) {
          issues.push(`Test '${testId}' depends on '${dependency}' which hasn't been executed yet`);
        }
      }
      
      executed.add(testId);
    }
    
    return { valid: issues.length === 0, issues };
  }

  /**
   * Get recommended execution order based on dependencies and priorities
   */
  getRecommendedExecutionOrder(testIds: string[]): string[] {
    const testMetadata = testIds.map(id => ({
      id,
      metadata: this.getTestMetadata(id)
    })).filter(item => item.metadata);

    // Sort by priority first (higher priority first)
    testMetadata.sort((a, b) => {
      const priorityA = a.metadata!.priority || 0;
      const priorityB = b.metadata!.priority || 0;
      return priorityB - priorityA;
    });

    // TODO: Implement topological sort for dependencies
    return testMetadata.map(item => item.id);
  }

  /**
   * Export metadata to JSON
   */
  exportMetadata(): string {
    const exportData = {
      metadata: Object.fromEntries(this.metadataStore),
      executionHistory: Object.fromEntries(this.executionHistory),
      exportedAt: new Date().toISOString(),
      version: '1.0.0'
    };
    
    return JSON.stringify(exportData, null, 2);
  }

  /**
   * Import metadata from JSON
   */
  importMetadata(jsonData: string, merge: boolean = false): void {
    try {
      const data = JSON.parse(jsonData);
      
      if (!merge) {
        this.metadataStore.clear();
        this.executionHistory.clear();
      }
      
      if (data.metadata) {
        Object.entries(data.metadata).forEach(([testId, metadata]) => {
          this.metadataStore.set(testId, metadata as TestMetadata);
        });
      }
      
      if (data.executionHistory) {
        Object.entries(data.executionHistory).forEach(([testId, history]) => {
          this.executionHistory.set(testId, history as TestExecutionRecord[]);
        });
      }
    } catch (error) {
      throw new Error(`Failed to import metadata: ${(error as Error).message}`);
    }
  }

  /**
   * Get comprehensive test suite analytics
   */
  getTestSuiteAnalytics(): TestSuiteAnalytics {
    const totalTests = this.metadataStore.size;
    let totalExecutions = 0;
    let totalDuration = 0;
    let passCount = 0;
    let failCount = 0;
    let flakyTests = 0;
    let slowTests = 0;
    
    const tagDistribution = new Map<string, number>();
    const categoryDistribution = new Map<string, number>();
    const authorDistribution = new Map<string, number>();
    
    this.metadataStore.forEach((metadata, testId) => {
      // Tag distribution
      if (metadata.tags) {
        metadata.tags.forEach(tag => {
          tagDistribution.set(tag, (tagDistribution.get(tag) || 0) + 1);
        });
      }
      
      // Category distribution
      if (metadata.category) {
        categoryDistribution.set(metadata.category, (categoryDistribution.get(metadata.category) || 0) + 1);
      }
      
      // Author distribution
      if (metadata.author?.name) {
        authorDistribution.set(metadata.author.name, (authorDistribution.get(metadata.author.name) || 0) + 1);
      }
      
      // Statistics aggregation
      if (metadata.statistics) {
        totalExecutions += metadata.statistics.totalExecutions;
        totalDuration += metadata.statistics.averageDuration * metadata.statistics.totalExecutions;
        passCount += metadata.statistics.passCount;
        failCount += metadata.statistics.failCount;
        
        if (metadata.statistics.flakyScore > 0.5) {
          flakyTests++;
        }
        
        if (metadata.statistics.averageDuration > 5000) {
          slowTests++;
        }
      }
    });
    
    return {
      overview: {
        totalTests,
        totalExecutions,
        averageDuration: totalExecutions > 0 ? totalDuration / totalExecutions : 0,
        overallSuccessRate: totalExecutions > 0 ? (passCount / (passCount + failCount)) * 100 : 0,
        flakyTestCount: flakyTests,
        slowTestCount: slowTests
      },
      distributions: {
        tags: Object.fromEntries(tagDistribution),
        categories: Object.fromEntries(categoryDistribution),
        authors: Object.fromEntries(authorDistribution)
      },
      trends: this.calculateTrends(),
      recommendations: this.generateRecommendations()
    };
  }

  /**
   * Clear all metadata and history
   */
  clear(): void {
    this.metadataStore.clear();
    this.executionHistory.clear();
  }

  /**
   * Get metadata store size
   */
  size(): number {
    return this.metadataStore.size;
  }

  /**
   * Check if test metadata exists
   */
  hasTest(testId: string): boolean {
    return this.metadataStore.has(testId);
  }

  /**
   * Get all test IDs
   */
  getAllTestIds(): string[] {
    return Array.from(this.metadataStore.keys());
  }

  // ==========================================
  // PRIVATE METHODS
  // ==========================================

  private validateTestId(testId: string): void {
    if (typeof testId !== 'string' || testId.trim() === '') {
      throw new Error('Test ID must be a non-empty string');
    }
  }

  private validateMetadata(metadata: TestMetadata): void {
    if (metadata.timeout !== undefined) {
      if (typeof metadata.timeout !== 'number' || metadata.timeout <= 0) {
        throw new Error('Timeout must be a positive number');
      }
    }
    
    if (metadata.retries !== undefined) {
      if (typeof metadata.retries !== 'number' || metadata.retries < 0) {
        throw new Error('Retries must be a non-negative number');
      }
    }
    
    if (metadata.priority !== undefined) {
      if (typeof metadata.priority !== 'number') {
        throw new Error('Priority must be a number');
      }
    }
  }

  private generateVersion(currentVersion?: string): string {
    if (!currentVersion) {
      return '1.0.0';
    }
    
    const parts = currentVersion.split('.').map(Number);
    parts[2]++; // Increment patch version
    return parts.join('.');
  }

  private updateExecutionStatistics(testId: string, record: TestExecutionRecord): void {
    const metadata = this.metadataStore.get(testId);
    if (!metadata) return;
    
    const history = this.executionHistory.get(testId) || [];
    const stats = this.calculateStatistics(history);
    
    metadata.statistics = stats;
    metadata.lastModified = new Date();
    
    this.metadataStore.set(testId, metadata);
  }

  private calculateStatistics(history: TestExecutionRecord[]): TestStatistics {
    if (history.length === 0) {
      return {
        totalExecutions: 0,
        passCount: 0,
        failCount: 0,
        skipCount: 0,
        errorCount: 0,
        averageDuration: 0,
        minDuration: 0,
        maxDuration: 0,
        successRate: 0,
        flakyScore: 0
      };
    }
    
    const durations = history.map(record => record.duration);
    const totalExecutions = history.length;
    const passCount = history.filter(record => record.result === 'pass').length;
    const failCount = history.filter(record => record.result === 'fail').length;
    const skipCount = history.filter(record => record.result === 'skip').length;
    const errorCount = history.filter(record => record.result === 'error').length;
    
    const averageDuration = durations.reduce((sum, duration) => sum + duration, 0) / totalExecutions;
    const minDuration = Math.min(...durations);
    const maxDuration = Math.max(...durations);
    const successRate = (passCount / totalExecutions) * 100;
    const flakyScore = this.calculateFlakyScore(history);
    
    return {
      totalExecutions,
      passCount,
      failCount,
      skipCount,
      errorCount,
      averageDuration,
      minDuration,
      maxDuration,
      successRate,
      flakyScore,
      lastExecution: history[history.length - 1]?.timestamp,
      firstExecution: history[0]?.timestamp
    };
  }

  private calculateFlakyScore(history: TestExecutionRecord[]): number {
    if (history.length < 5) return 0; // Need at least 5 runs to determine flakiness
    
    let changes = 0;
    for (let i = 1; i < history.length; i++) {
      if (history[i].result !== history[i - 1].result) {
        changes++;
      }
    }
    
    return changes / (history.length - 1);
  }

  private calculateTrends(): TestTrends {
    // Simplified trend calculation
    return {
      successRateTrend: 'stable',
      durationTrend: 'stable',
      flakyTestTrend: 'stable',
      testCountTrend: 'increasing'
    };
  }

  private generateRecommendations(): TestRecommendation[] {
    const recommendations: TestRecommendation[] = [];
    
    const flakyTests = this.findFlakyTests(0.3);
    if (flakyTests.size > 0) {
      recommendations.push({
        type: 'warning',
        category: 'stability',
        message: `Found ${flakyTests.size} flaky tests that should be investigated`,
        affectedTests: Array.from(flakyTests.keys())
      });
    }
    
    const slowTests = this.findSlowTests(30000); // 30 seconds
    if (slowTests.size > 0) {
      recommendations.push({
        type: 'info',
        category: 'performance',
        message: `Found ${slowTests.size} slow tests that could be optimized`,
        affectedTests: Array.from(slowTests.keys())
      });
    }
    
    const unreliableTests = this.findUnreliableTests(0.7);
    if (unreliableTests.size > 0) {
      recommendations.push({
        type: 'error',
        category: 'reliability',
        message: `Found ${unreliableTests.size} unreliable tests with low success rates`,
        affectedTests: Array.from(unreliableTests.keys())
      });
    }
    
    return recommendations;
  }
}

// ==========================================
// INTERFACES AND TYPES
// ==========================================

export interface TestSuiteAnalytics {
  overview: {
    totalTests: number;
    totalExecutions: number;
    averageDuration: number;
    overallSuccessRate: number;
    flakyTestCount: number;
    slowTestCount: number;
  };
  distributions: {
    tags: Record<string, number>;
    categories: Record<string, number>;
    authors: Record<string, number>;
  };
  trends: TestTrends;
  recommendations: TestRecommendation[];
}

export interface TestTrends {
  successRateTrend: 'improving' | 'degrading' | 'stable';
  durationTrend: 'improving' | 'degrading' | 'stable';
  flakyTestTrend: 'improving' | 'degrading' | 'stable';
  testCountTrend: 'increasing' | 'decreasing' | 'stable';
}

export interface TestRecommendation {
  type: 'info' | 'warning' | 'error';
  category: 'performance' | 'stability' | 'reliability' | 'maintenance';
  message: string;
  affectedTests: string[];
  suggestion?: string;
  priority?: number;
}